#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Feb 10 09:32:34 2020

@author: ravinderjit

Calculate system functions from EEG data for Dynamic Binaural Msequence project
"""

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import scipy.io as sio
import os
import pickle
import numpy as np
import scipy as sp
from anlffr.spectral import mtspecraw
from spectralAnalysis import periodogram
from multiprocessing import Pool
# import mne


def PLV_Coh(X,Y,TW,fs):
    """
    X is the Mseq
    Y is time x trials
    TW is half bandwidth product 
    """
    X = X.squeeze()
    ntaps = 2*TW - 1
    dpss = sp.signal.windows.dpss(Mseq.size,TW,ntaps)
    N = int(2**np.ceil(np.log2(Mseq.size)))
    f = np.arange(0,N)*fs/N
    PLV_taps = np.zeros([N,ntaps])
    Coh_taps = np.zeros([N,ntaps])
    Phase_taps = np.zeros([N,ntaps])
    for k in range(0,ntaps):
        print('tap:',k+1,'/',ntaps)
        Xf = sp.fft(X *dpss[k,:],axis=0,n=N)
        Yf = sp.fft(Y * dpss[k,:].reshape(dpss.shape[1],1),axis=0,n=N)
        XYf = Xf.reshape(Xf.shape[0],1).conj() * Yf
        Phase_taps[:,k] = np.unwrap(np.angle(np.mean(XYf / abs(XYf),axis=1)))
        PLV_taps[:,k] = abs(np.mean(XYf / abs(XYf),axis=1))
        Coh_taps[:,k] = abs(np.mean(XYf,axis=1) / np.mean(abs(XYf),axis=1))
        
    PLV = PLV_taps.mean(axis=1)
    Coh = Coh_taps.mean(axis=1)
    Phase = Phase_taps.mean(axis=1)
    return PLV, Coh, f, Phase

direct_Mseq = '/media/ravinderjit/Data_Drive/Data/EEGdata/DynamicBinaural/Mseq_4096fs_compensated.mat'
data_loc = os.path.abspath('/media/ravinderjit/Data_Drive/Data/EEGdata/DynamicBinaural/Pickles')

Mseq_mat = sio.loadmat(direct_Mseq)
Mseq = Mseq_mat['Mseq_sig'].T
Mseq = Mseq.astype(float)

Num_noiseFloors = 100
Keep_H = 1 #length of system function to keep in seconds 

Subjects = ['S001','S132','S203','S204','S205','S206','S207','S208','S211']

for subj in range(0,len(Subjects)):
    Subject = Subjects[subj]
    print(Subject, '.........................')
    with open(os.path.join(data_loc, Subject+'_DynBin.pickle'),'rb') as f:
        IAC_epochs, ITD_epochs = pickle.load(f)
    
    t = IAC_epochs.times
    fs = IAC_epochs.info['sfreq']
    IAC32 = IAC_epochs.get_data()
    ITD32 = ITD_epochs.get_data()
    IAC32 = IAC32.T[:,0,:]
    ITD32 = ITD32.T[:,0,:]
    
    #%% Plot PSD, should be clear ASSR at 20 Hz
    fig = IAC_epochs.plot_psd(fmin=0, fmax=50, tmin = 0.0, tmax=12.75, proj=True,average=False)
    fig.suptitle(Subject + ' IAC')
    fig.savefig('/media/ravinderjit/Data_Drive/Data/Figures/DynBin/A32_PSD/' + Subject +'_IAC')
    fig = ITD_epochs.plot_psd(fmin=0, fmax=50, tmin = 0.0, tmax=12.75, proj=True,average=False)
    fig.suptitle(Subject + ' ITD')
    fig.savefig('/media/ravinderjit/Data_Drive/Data/Figures/DynBin/A32_PSD/' + Subject +'_ITD')
    #%% Remove any epochs with large deflections
    Peak2Peak_IAC = IAC32.max(axis=0) - IAC32.min(axis=0)
    IAC32 = IAC32[:,Peak2Peak_IAC*1e6 < 100.]
    Peak2Peak_ITD =ITD32.max(axis=0) - ITD32.min(axis=0)
    ITD32 = ITD32[:,Peak2Peak_ITD*1e6 < 100.]
    
    #%% visualize epochs
    # plt.figure()
    # plt.plot(t,IAC32*1e6)
    # plt.plot(t,IAC32.mean(axis=1)*1e6,linewidth=3,color='k')
    # plt.title('IAC')
    # plt.figure()
    # plt.plot(t,ITD32*1e6)
    # plt.plot(t,ITD32.mean(axis=1)*1e6,linewidth=3,color='k')
    # plt.title('ITD')
    
    #%% Extract part of response when stim is on
    t1 = np.where(t>=0)[0][0]
    t2 = np.where(t>=12.75)[0][0]
    t = t[t1:t2]
    IAC32 = IAC32[t1:t2,:]
    ITD32 = ITD32[t1:t2,:]
    
    #%% Generate Noise Floors
    # Generated by subtracting half of epochs from each other
    IAC_nfs = np.zeros([Num_noiseFloors,Mseq.size])
    ITD_nfs = np.zeros([Num_noiseFloors,Mseq.size])
    for nn in range(0,Num_noiseFloors):
        randInds = np.random.permutation(IAC32.shape[1]) #random inds for epochs
        IAC_Noise = (IAC32[:, randInds[0:int(np.round(randInds.size/2))]].sum(axis=1) - \
                     IAC32[:, randInds[int(np.round(randInds.size/2)):]].sum(axis=1)) / randInds.size
        randInds = np.random.permutation(ITD32.shape[1])
        ITD_Noise = (ITD32[:, randInds[0:int(np.round(randInds.size/2))]].sum(axis=1) - \
            ITD32[:, randInds[int(np.round(randInds.size/2)):]].sum(axis=1)) / randInds.size
        
        IAC_nf = np.correlate(IAC_Noise,Mseq[:,0],mode='full')
        IAC_nfs[nn,:] = IAC_nf[Mseq.size-1:]
        ITD_nf = np.correlate(ITD_Noise,Mseq[:,0],mode='full')
        ITD_nfs[nn,:] = ITD_nf[Mseq.size-1:]
        
    #%% Calculate Ht
    IAC_Ht = np.correlate(IAC32.mean(axis=1),Mseq[:,0],mode='full')
    IAC_Ht = IAC_Ht[Mseq.size-1:]
    
    ITD_Ht = np.correlate(ITD32.mean(axis=1),Mseq[:,0],mode='full')
    ITD_Ht = ITD_Ht[Mseq.size-1:]
    
    # plt.figure()
    # plt.plot(t,IAC_nfs.T,color= mcolors.CSS4_COLORS['grey'])
    # plt.plot(t,IAC_Ht,color='k')
    # plt.xlim([0,Keep_H])
    # plt.title('Ht IAC')
    
    # plt.figure()
    # plt.plot(t,ITD_nfs.T,color= mcolors.CSS4_COLORS['grey'])
    # plt.plot(t,ITD_Ht,color='k')
    # plt.xlim([0,Keep_H])
    # plt.title('Ht ITD')
    
    #%% Calculate Hf
    params = {'Fs':fs, 'tapers':[1.5,2], 'fpass':[0,40]}
    IAC_getHf = IAC_Ht[:int(np.round(Keep_H*fs))]
    IAC_getHf = IAC_getHf.reshape([1,IAC_getHf.size])
    
    ITD_getHF = ITD_Ht[:int(np.round(Keep_H*fs))]
    ITD_getHF = ITD_getHF.reshape([1,ITD_getHF.size])
    
    out_IAC = mtspecraw(IAC_getHf,params)
    out_ITD = mtspecraw(ITD_getHF,params)
    IAC_Hf = out_IAC[0]
    ITD_Hf = out_ITD[0]
    f1 = out_IAC[1]
    
    NF_Hfs_IAC = np.zeros([Num_noiseFloors,IAC_Hf.size])
    NF_Hfs_ITD = np.zeros([Num_noiseFloors,ITD_Hf.size])
    for j in range(0,Num_noiseFloors):
        NF_getHf_IAC = IAC_nfs[j,:int(np.round(Keep_H*fs))]
        NF_getHf_IAC = NF_getHf_IAC.reshape([1,NF_getHf_IAC.size])
        NF_getHf_ITD = ITD_nfs[j,:int(np.round(Keep_H*fs))]
        NF_getHf_ITD = NF_getHf_ITD.reshape([1,NF_getHf_ITD.size])
        
        out_NF_IAC = mtspecraw(NF_getHf_IAC,params)
        out_NF_ITD = mtspecraw(NF_getHf_ITD,params)
        NF_Hfs_IAC[j,:] = out_NF_IAC[0]
        NF_Hfs_ITD[j,:] = out_NF_ITD[0]
    
    # fig = plt.figure()
    # plt.plot(f1,10*np.log10(IAC_Hf),color='k')
    # plt.plot(f1,10*np.log10(NF_Hfs_IAC.T),color= mcolors.CSS4_COLORS['grey'])
    # # fig.axes[0].set_xscale('log')
    # plt.xlim([0,20])
    # plt.title('CrossCorr IAC')
    
    # fig = plt.figure()
    # plt.plot(f1,10*np.log10(ITD_Hf),color='k')
    # plt.plot(f1,10*np.log10(NF_Hfs_ITD.T),color= mcolors.CSS4_COLORS['grey'])
    # # fig.axes[0].set_xscale('log')
    # plt.xlim([0,20])
    # plt.title('CrossCorr ITD')
    
    
    
    
    #%% Calculate TMTF via PLV
    
    TW = 10
    Fres = (1/12.75) * TW * 2 
    PLV_IAC, Coh_IAC, f2, phase_IAC = PLV_Coh(Mseq,IAC32,TW,fs)
    PLV_ITD, Coh_ITD, f2, phase_ITD = PLV_Coh(Mseq,ITD32,TW,fs)
    
    #Noise FLoors
    PLVnf_IAC = np.zeros([PLV_IAC.shape[0],Num_noiseFloors])
    Cohnf_IAC = np.zeros([PLV_IAC.shape[0],Num_noiseFloors])
    PLVnf_ITD = np.zeros([PLV_ITD.shape[0],Num_noiseFloors])
    Cohnf_ITD = np.zeros([PLV_ITD.shape[0],Num_noiseFloors])
    
    for nf in range(0,Num_noiseFloors):
        print('NF:', nf+1, '/',Num_noiseFloors)
        order_IAC = np.random.permutation(IAC32.shape[1])
        order_ITD = np.random.permutation(ITD32.shape[1])
        Y_IAC = IAC32[:,order_IAC]
        Y_ITD = ITD32[:,order_ITD]
        Y_IAC[:,0:int(np.round(order_IAC.size/2))] = -Y_IAC[:,0:int(np.round(order_IAC.size/2))]
        Y_ITD[:,0:int(np.round(order_ITD.size/2))] = -Y_ITD[:,0:int(np.round(order_ITD.size/2))]
        
        PLVn_IAC, Cohn_IAC, f, phase = PLV_Coh(Mseq, Y_IAC, TW,fs)
        PLVn_ITD, Cohn_ITD, f, phase = PLV_Coh(Mseq, Y_ITD, TW,fs)
        PLVnf_IAC[:,nf] = PLVn_IAC
        Cohnf_IAC[:,nf] = Cohn_IAC
        PLVnf_ITD[:,nf] = PLVn_ITD
        Cohnf_ITD[:,nf] = Cohn_ITD
        
    # fig = plt.figure()
    # plt.plot(f2,Coh_IAC,color='k')
    # plt.plot(f2,Cohnf_IAC,color= mcolors.CSS4_COLORS['grey'])
    # plt.title('Coh IAC')
    # fig.axes[0].set_xscale('log')
    # plt.xlim([1,20])
    
    # fig = plt.figure()
    # plt.plot(f2,Coh_ITD,color='k')
    # plt.plot(f2,Cohnf_ITD,color= mcolors.CSS4_COLORS['grey'])
    # plt.title('Coh ITD')
    # plt.xlim([1,20])
    # fig.axes[0].set_xscale('log')
    
    with open(os.path.join(data_loc,'SystemFuncs', Subject+'_DynBin_SysFuncTW' + str(TW) + '.pickle'),'wb') as f:     
        pickle.dump([IAC_Ht, IAC_nfs, IAC_Hf, NF_Hfs_IAC, PLV_IAC, Coh_IAC, PLVnf_IAC, Cohnf_IAC, \
                     ITD_Ht, ITD_nfs, ITD_Hf, NF_Hfs_ITD, PLV_ITD, Coh_ITD, PLVnf_ITD, Cohnf_ITD, f1,f2,t, phase_IAC,phase_ITD],f)
        
        
    
    
    
        
        
        
        
    
    
    
    
    
    
    
    
    





