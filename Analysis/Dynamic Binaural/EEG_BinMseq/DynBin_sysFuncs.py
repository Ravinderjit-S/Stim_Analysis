#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Feb 10 09:32:34 2020

@author: ravinderjit

Calculate system functions from EEG data for Dynamic Binaural Msequence project
"""

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import scipy.io as sio
import os
import pickle
import numpy as np
import scipy as sp
from anlffr.spectral import mtspecraw
from spectralAnalysis import periodogram
# import mne


def PLV_Coh(X,Y,TW,fs):
    """
    X is the Mseq
    Y is time x trials
    TW is half bandwidth product 
    """
    X = X.squeeze()
    ntaps = 2*TW - 1
    dpss = sp.signal.windows.dpss(Mseq.size,TW,ntaps)
    N = int(2**np.ceil(np.log2(Mseq.size)))
    f = np.arange(0,N)*fs/N
    PLV_taps = np.zeros([N,ntaps])
    Coh_taps = np.zeros([N,ntaps])
    
    for k in range(0,ntaps):
        print('tap:',k+1,'/',ntaps)
        Xf = sp.fft(X *dpss[k,:],axis=0,n=N)
        Yf = sp.fft(Y * dpss[k,:].reshape(dpss.shape[1],1),axis=0,n=N)
        XYf = Xf.reshape(Xf.shape[0],1) * Yf.conj()
        PLV_taps[:,k] = abs(np.mean(XYf / abs(XYf),axis=1))
        Coh_taps[:,k] = abs(np.mean(XYf,axis=1) / np.mean(abs(XYf),axis=1))
        
    PLV = PLV_taps.mean(axis=1)
    Coh = Coh_taps.mean(axis=1)
    return PLV, Coh, f

direct_Mseq = '/media/ravinderjit/Data_Drive/Data/EEGdata/DynamicBinaural/Mseq_4096fs_compensated.mat'
data_loc = os.path.abspath('/media/ravinderjit/Data_Drive/Data/EEGdata/DynamicBinaural/Pickles')

Mseq_mat = sio.loadmat(direct_Mseq)
Mseq = Mseq_mat['Mseq_sig'].T
Mseq = Mseq.astype(float)

Num_noiseFloors = 10
Keep_H = 1 #length of system function to keep in seconds 

Subjects = ['S001','S132','S203','S204','S205','S206','S207','S208','S211']
Subject = Subjects[6]

with open(os.path.join(data_loc, Subject+'_DynBin.pickle'),'rb') as f:
    IAC_epochs, ITD_epochs = pickle.load(f)

t = IAC_epochs.times
fs = IAC_epochs.info['sfreq']
IAC32 = IAC_epochs.get_data()
ITD32 = ITD_epochs.get_data()
IAC32 = IAC32.T[:,0,:]
ITD32 = ITD32.T[:,0,:]

#%% Plot PSD, should be clear ASSR at 20 Hz
IAC_epochs.plot_psd(fmin=0, fmax=50, tmin = 0.0, tmax=12.75, proj=True,average=False)
ITD_epochs.plot_psd(fmin=0, fmax=50, tmin = 0.0, tmax=12.75, proj=True,average=False)

#%% Remove any epochs with large deflections
Peak2Peak_IAC = IAC32.max(axis=0) - IAC32.min(axis=0)
IAC32 = IAC32[:,Peak2Peak_IAC*1e6 < 100.]
Peak2Peak_ITD =ITD32.max(axis=0) - ITD32.min(axis=0)
ITD32 = ITD32[:,Peak2Peak_ITD*1e6 < 100.]

#%% visualize epochs
plt.figure()
plt.plot(t,IAC32*1e6)
plt.plot(t,IAC32.mean(axis=1)*1e6,linewidth=3,color='k')
plt.title('IAC')
plt.figure()
plt.plot(t,ITD32*1e6)
plt.plot(t,ITD32.mean(axis=1)*1e6,linewidth=3,color='k')
plt.title('ITD')

#%% Extract part of response when stim is on
t1 = np.where(t>=0)[0][0]
t2 = np.where(t>=12.75)[0][0]
t = t[t1:t2]
IAC32 = IAC32[t1:t2,:]
ITD32 = ITD32[t1:t2,:]

#%% Generate Noise Floors
# Generated by subtracting half of epochs from each other
IAC_nfs = np.zeros([Num_noiseFloors,Mseq.size])
ITD_nfs = np.zeros([Num_noiseFloors,Mseq.size])
for nn in range(0,Num_noiseFloors):
    randInds = np.random.permutation(IAC32.shape[1]) #random inds for epochs
    IAC_Noise = (IAC32[:, randInds[0:int(np.round(randInds.size/2))]].sum(axis=1) - \
                 IAC32[:, randInds[int(np.round(randInds.size/2)):]].sum(axis=1)) / randInds.size
    randInds = np.random.permutation(ITD32.shape[1])
    ITD_Noise = (ITD32[:, randInds[0:int(np.round(randInds.size/2))]].sum(axis=1) - \
        ITD32[:, randInds[int(np.round(randInds.size/2)):]].sum(axis=1)) / randInds.size
    
    IAC_nf = np.correlate(IAC_Noise,Mseq[:,0],mode='full')
    IAC_nfs[nn,:] = IAC_nf[Mseq.size-1:]
    ITD_nf = np.correlate(ITD_Noise,Mseq[:,0],mode='full')
    ITD_nfs[nn,:] = ITD_nf[Mseq.size-1:]
    
#%% Calculate Ht
IAC_Ht = np.correlate(IAC32.mean(axis=1),Mseq[:,0],mode='full')
IAC_Ht = IAC_Ht[Mseq.size-1:]

plt.figure()
plt.plot(t,IAC_nfs.T,color= mcolors.CSS4_COLORS['grey'])
plt.plot(t,IAC_Ht,color='k')
plt.xlim([0,Keep_H])

#%% Calculate Hf
params = {'Fs':fs, 'tapers':[1.5,2], 'fpass':[0,40]}
IAC_getHf = IAC_Ht[:int(np.round(Keep_H*fs))]
IAC_getHf = IAC_getHf.reshape([1,IAC_getHf.size])

out_IAC = mtspecraw(IAC_getHf,params)
IAC_Hf = 10*np.log10(out_IAC[0])
f = out_IAC[1]

NF_Hfs = np.zeros([Num_noiseFloors,IAC_Hf.size])
for j in range(0,Num_noiseFloors):
    NF_getHf = IAC_nfs[j,:int(np.round(Keep_H*fs))]
    NF_getHf = NF_getHf.reshape([1,NF_getHf.size])
    out_NF = mtspecraw(NF_getHf,params)
    NF_Hfs[j,:] = 10*np.log10(out_NF[0])

fig = plt.figure()
plt.plot(f,IAC_Hf,color='k')
plt.plot(f,NF_Hfs.T,color= mcolors.CSS4_COLORS['grey'])
# fig.axes[0].set_xscale('log')
plt.xlim([0,20])
plt.title('CrossCorr')

#%% Calculate TMTF via PLV

TW = 7
Fres = (1/12.75) * TW * 2 
PLV, Coh, f = PLV_Coh(Mseq,IAC32,TW,fs)

#Noise FLoors
PLVnf = np.zeros([PLV.shape[0],Num_noiseFloors])
Cohnf = np.zeros([PLV.shape[0],Num_noiseFloors])
for nf in range(0,Num_noiseFloors):
    print('NF:', nf+1, '/',Num_noiseFloors)
    order = np.random.permutation(IAC32.shape[1])
    Y = IAC32[:,order]
    Y[:,0:int(np.round(order.size/2))] = - Y[:,0:int(np.round(order.size/2))]
    PLVn, Cohn, f = PLV_Coh(Mseq, Y, TW,fs)
    PLVnf[:,nf] = PLVn
    Cohnf[:,nf] = Cohn

#Plot stuff
plt.figure()
plt.plot(f,PLV,color='k')
plt.plot(f,PLVnf,color= mcolors.CSS4_COLORS['grey'])
plt.title('PLV')

plt.figure()
plt.plot(f,Coh,color='k')
plt.plot(f,Cohnf,color= mcolors.CSS4_COLORS['grey'])
plt.title('Coh')
        




    
    
    
    














